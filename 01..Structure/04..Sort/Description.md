# 정렬

## 선택정렬

- 선택 정렬은 제자리 비교 정렬이다. 복잡도는 𝑂(𝑁^2)이므로 큰 리스트에는 비효율적이며, 유사한 삽입 정렬보다 성능이 더 떨어지는 것이 일반적이다. 선택 정렬은 단순함이 특징이며 특정한 상황에서는 더 복잡한 알고리즘보다 성능상 우위가 있다.
- 이 알고리즘은 최소값을 찾고 값을 최초 위치와 바꿔친 다음 리스트의 나머지 부분에 대해 이 과정을 반복한다. 교환 과정은 n개를 넘지 않으므로 교환 비용이 많이 드는 상황에서 유용하다.
- 출처 : [https://ko.wikipedia.org/wiki/선택\_정렬](https://ko.wikipedia.org/wiki/%EC%84%A0%ED%83%9D_%EC%A0%95%EB%A0%AC)

## 삽입정렬

- 삽입 정렬이란 각 숫자를 적절한 위치에 삽입하는 정렬 기법입니다. 들어갈 위치를 선택하는 데에 N번, 선택하는 횟수로 N번이므로 𝑂(𝑁^2) 의 시간 복잡도를 가집니다
- 삽입 정렬은 작은 리스트와 대부분 정렬된 리스트에 상대적으로 효율적인 단순한 정렬 알고리즘이며 더 복잡한 알고리즘의 일부분으로 사용되기도 한다.
- 리스트로부터 요소를 하나씩 취한 다음 마치 돈을 지갑에 넣는 방식과 비슷하게 이들을 올바른 위치에, 새로 정렬된 리스트에 삽입함으로써 동작한다. 배열의 경우 새 리스트와 남아있는 요소들은 배열 공간을 공유할 수 있으나 삽입의 경우 잇따르는 모든 요소를 하나씩 이동해야 하므로 비용이 많이 든다. 셸소트는 큰 리스트에 더 효율적인 삽입 정렬의 변종이다.
- 출처 : [https://ko.wikipedia.org/wiki/삽입\_정렬](https://ko.wikipedia.org/wiki/%EC%A0%95%EB%A0%AC_%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98#%EC%82%BD%EC%9E%85_%EC%A0%95%EB%A0%AC)

## 병합정렬

- 합병 정렬 또는 병합 정렬(merge sort)은 O(n log n) 비교 기반 정렬 알고리즘이다.

1. 리스트의 길이가 1 이하이면 이미 정렬된 것으로 본다. 그렇지 않은 경우에는
2. 분할(divide) : 정렬되지 않은 리스트를 절반으로 잘라 비슷한 크기의 두 부분 리스트로 나눈다.
3. 정복(conquer) : 각 부분 리스트를 [재귀](https://ko.wikipedia.org/wiki/%EC%9E%AC%EA%B7%80%ED%95%A8%EC%88%98)적으로 합병 정렬을 이용해 정렬한다.
4. 결합(combine) : 두 부분 리스트를 다시 하나의 정렬된 리스트로 합병한다. 이때 정렬 결과가 임시배열에 저장된다.
5. 복사(copy) : 임시 배열에 저장된 결과를 원래 배열에 복사한다.

- 출처 : [https://ko.wikipedia.org/wiki/합병\_정렬](https://ko.wikipedia.org/wiki/%ED%95%A9%EB%B3%91_%EC%A0%95%EB%A0%AC)

## 퀵정렬

- 퀵 정렬은 분할 정복(divide and conquer) 방법을 통해 리스트를 정렬한다.
- 퀵 정렬은 피벗을 기준으로 큰 값과 작은 값을 서로 교체하는 정렬 기법입니다. 값을 서로 교체하는
  데에 𝑁번, 엇갈린 경우 교체 이후에 원소가 반으로 나누어지므로 전체 원소를 나누는 데에 평균적으로 𝑙𝑜𝑔𝑁번이 소요되므로 평균적으로 𝜃(𝑁𝑙𝑜𝑔𝑁) 의 시간 복잡도를 가집니다
- 원소를 절반씩 나눌 때 𝑙𝑜𝑔𝑁의 시간 복잡도가 나오는 대표적인 예시는 완전 이진 트리입니다.

1. 리스트 가운데서 하나의 원소를 고른다. 이렇게 고른 원소를 **피벗**이라고 한다.
2. 피벗 앞에는 피벗보다 값이 작은 모든 원소들이 오고, 피벗 뒤에는 피벗보다 값이 큰 모든 원소들이 오도록 피벗을 기준으로 리스트를 둘로 나눈다. 이렇게 리스트를 둘로 나누는 것을 **분할**이라고 한다. 분할을 마친 뒤에 피벗은 더 이상 움직이지 않는다.
3. 분할된 두 개의 작은 리스트에 대해 재귀(Recursion)적으로 이 과정을 반복한다. 재귀는 리스트의 크기가 0이나 1이 될 때까지 반복된다.

재귀 호출이 한번 진행될 때마다 최소한 하나의 원소는 최종적으로 위치가 정해지므로, 이 알고리즘은 반드시 끝난다는 것을 보장할 수 있다.

- 출처 : [https://ko.wikipedia.org/wiki/퀵\_정렬](https://ko.wikipedia.org/wiki/%ED%80%B5_%EC%A0%95%EB%A0%AC)

## 계수정렬 (Counting Sort)

- 계수 정렬(Counting Sort)는 크기를 기준으로 데이터의 개수를 세는 정렬 알고리즘입니다. 각 데이터를 바로 크기를 기준으로 분류하므로 𝑂(𝑁)의 시간 복잡도를 가집니다.
- 계수 정렬은 데이터의 크기가 한정적일 때 사용할 수 있습니다

step 1
| index | 0 | 1 | 2 | 3 |
| ------- | --- | --- | --- | --- |
| element | 0 | 0 | 1 | 0 |

| 2 (확인) | 0 | 1 | 2 | 3 |

step 2
| index | 0 | 1 | 2 | 3 |
| ------- | --- | --- | --- | --- |
| element | 1 | 0 | 1 | 0 |

| 2 (확인) | 0 (확인) | 1 | 2 | 3 |

중략..

차례대로 최종 값대로 정렬.

## 기수정렬 (Radix Sort)

- 기수 정렬(Radix Sort)는 자릿수를 기준으로 차례대로 데이터를 정렬하는 알고리즘입니다. 각 데이터를 자릿수를 기준으로 분류하므로 가장 큰 자릿수를 D라고 했을 때 𝑂(𝐷𝑁)의 시간 복잡도를 가집니다.
- 기수 정렬은 계수 정렬보다 약간 더 느리지만, 숫자가 매우 큰 상황에서도 사용할 수 있습니다
- 참고
  > https://www.zerocho.com/category/Algorithm/post/58007c338475ed00152d6c4c > https://rninche01.tistory.com/entry/%EC%A0%95%EB%A0%AC-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-05-%EA%B3%84%EC%88%98-%EB%B0%8F-%EA%B8%B0%EC%88%98-%EC%A0%95%EB%A0%ACCounting-Sort-Radix-Sort

|         |     |     |     |     |     |     |     |     |     |     |
| ------- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| index   | 7   | 84  | 25  | 341 | 65  | 30  | 34  |     |     |     |
| result  |     |     |     |     |     |     |     |     |     |     |
| tempArr | 0   | 1   | 2   | 3   | 4   | 5   | 6   | 7   | 8   | 9   |
|         | 0   | 0   | 0   | 0   | 0   | 0   | 0   | 0   | 0   | 0   |

#1의 자리

|            |       |        |        |         |        |        |        |     |     |     |
| ---------- | ----- | ------ | ------ | ------- | ------ | ------ | ------ | --- | --- | --- |
| index      | **7** | 8**4** | 2**5** | 34**1** | 6**5** | 3**0** | 3**4** |     |     |     |
| result     |       |        |        |         |        |        |        |     |     |     |
| 자릿수배열 | 0     | 1      | 2      | 3       | 4      | 5      | 6      | 7   | 8   | 9   |
| 누적값     | 1     | 1      | 0      | 0       | 2      | 2      | 0      | 1   | 0   | 0   |

누적을 해주면

|            |       |        |        |         |        |        |        |     |     |     |
| ---------- | ----- | ------ | ------ | ------- | ------ | ------ | ------ | --- | --- | --- |
| index      | **7** | 8**4** | 2**5** | 34**1** | 6**5** | 3**0** | 3**4** |     |     |     |
| result     |       |        |        |         |        |        |        |     |     |     |
| 자릿수배열 | 0     | 1      | 2      | 3       | 4      | 5      | 6      | 7   | 8   | 9   |
| 누적값     | 1     | 2      | 0      | 0       | 4      | 6      | 0      | 7   | 0   | 0   |

위 누적값을 바탕으로 결과 배열을 만든다
뒤에서부터 첫번쨰 값 34 를 누적값에서 4의 값이 4이기 때문에 4번째 인덱스에 넣어주고 값을 하나 빼준다.

|            |       |        |        |         |                                  |        |        |     |     |     |
| ---------- | ----- | ------ | ------ | ------- | -------------------------------- | ------ | ------ | --- | --- | --- |
| index      | **7** | 8**4** | 2**5** | 34**1** | 6**5**                           | 3**0** | 3**4** |     |     |     |
| result     |       |        |        | 34      |                                  |        |        |     |     |     |
| 자릿수배열 | 0     | 1      | 2      | 3       | 4                                | 5      | 6      | 7   | 8   | 9   |
| 누적값     | 1     | 2      | 0      | 0       | <span style="color:red">3</span> | 6      | 0      | 7   | 0   | 0   |

2번째
| | | | | | | | | | | |
| ---------- | ----- | ------ | ------ | ------- | ------ | ------ | ------ | --- | --- | --- |
| index | **7** | 8**4** | 2**5** | 34**1** | 6**5** | 3**0** | 3**4** | | | |
| result | 30 | | | 34 | | | | | | |
| 자릿수배열 | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 |
| 누적값 | <span style="color:red">0</span> | 2 | 0 | 0 | 4 | 6 | 0 | 7 | 0 | 0 |

결과배열
| | | | | | | | | | | |
| ---------- | ----- | ------ | ------ | ------- | ------ | ------ | ------ | --- | --- | --- |
| result | 30 | 341 | 84 | 34 | 25 | 65 | 7 | | | |
| 자릿수배열 | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 |
| 누적값 | 0 | 0 | 2 | 4 | 5 | 0 | 6 | 0 | 7| 0 |

반복..

#10의자리

|            |     |     |     |     |     |     |     |     |     |     |
| ---------- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| index      | 30  | 341 | 84  | 34  | 25  | 65  | 7   |     |     |     |
| result     | 7   | 25  | 30  | 34  | 341 | 65  | 84  |     |     |     |
| 자릿수배열 | 0   | 1   | 2   | 3   | 4   | 5   | 6   | 7   | 8   | 9   |
| 누적값     | 0   | 0   | 1   | 2   | 4   | 0   | 5   | 0   | 6   | 0   |

반복하면서 정렬함.
